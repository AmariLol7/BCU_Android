Index: app/src/main/java/common/util/Data.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package common.util;\r\n\r\nimport com.google.gson.JsonElement;\r\nimport com.google.gson.JsonObject;\r\nimport common.CommonStatic;\r\nimport common.io.assets.Admin.StaticPermitted;\r\nimport common.io.json.FieldOrder;\r\nimport common.io.json.FieldOrder.Order;\r\nimport common.io.json.JsonClass;\r\nimport common.io.json.JsonClass.NoTag;\r\nimport common.io.json.JsonDecoder;\r\nimport common.io.json.JsonEncoder;\r\nimport common.pack.Context.ErrType;\r\nimport common.pack.Context.RunExc;\r\nimport common.pack.Context.SupExc;\r\nimport common.pack.Identifier;\r\nimport common.util.pack.Background;\r\nimport common.util.pack.EffAnim.EffAnimStore;\r\nimport common.util.stage.Music;\r\n\r\nimport java.lang.annotation.*;\r\nimport java.lang.reflect.Field;\r\n\r\n@StaticPermitted\r\npublic class Data {\r\n\r\n\t@JsonClass(read = JsonClass.RType.MANUAL, write = JsonClass.WType.CLASS, generator = \"genProc\", serializer = \"serProc\")\r\n\tpublic static class Proc implements BattleStatic {\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class ARMOR extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int time;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int mult;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class BURROW extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int count;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int dis;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class IMU extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int mult;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int block;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class IMUAD extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int mult;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int block;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int smartImu;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class DMGCUT extends ProcItem {\r\n\t\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\t\tpublic static class TYPE extends IntType {\r\n\t\t\t\t@Order(0)\r\n\t\t\t\tpublic boolean traitIgnore;\r\n\t\t\t\t@Order(1)\r\n\t\t\t\tpublic boolean procs;\r\n\t\t\t\t@Order(2)\r\n\t\t\t\tpublic boolean magnif;\r\n\t\t\t}\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int dmg;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int reduction;\r\n\t\t\t@Order(3)\r\n\t\t\tpublic TYPE type = new TYPE();\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class DMGCAP extends ProcItem {\r\n\t\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\t\tpublic static class TYPE extends IntType {\r\n\t\t\t\t@Order(0)\r\n\t\t\t\tpublic boolean traitIgnore;\r\n\t\t\t\t@Order(1)\r\n\t\t\t\tpublic boolean nullify;\r\n\t\t\t\t@Order(2)\r\n\t\t\t\tpublic boolean procs;\r\n\t\t\t\t@Order(3)\r\n\t\t\t\tpublic boolean magnif;\r\n\t\t\t}\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int dmg;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic TYPE type = new TYPE();\r\n\t\t}\r\n\r\n\t\tpublic static abstract class IntType implements Cloneable, BattleStatic {\r\n\r\n\t\t\t@Documented\r\n\t\t\t@Retention(value = RetentionPolicy.RUNTIME)\r\n\t\t\t@Target(value = ElementType.FIELD)\r\n\t\t\tpublic @interface BitCount {\r\n\t\t\t\tint value();\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic IntType clone() throws CloneNotSupportedException {\r\n\t\t\t\treturn (IntType) super.clone();\r\n\t\t\t}\r\n\r\n\t\t\tpublic Field[] getDeclaredFields() {\r\n\t\t\t\treturn FieldOrder.getDeclaredFields(this.getClass());\r\n\t\t\t}\r\n\r\n\t\t\tpublic IntType load(int val) throws Exception {\r\n\t\t\t\tField[] fs = getDeclaredFields();\r\n\t\t\t\tfor (int i = 0; i < fs.length;) {\r\n\t\t\t\t\tBitCount c = fs[i].getAnnotation(BitCount.class);\r\n\t\t\t\t\tif (c == null) {\r\n\t\t\t\t\t\tfs[i].set(this, (val >> i & 1) == 1);\r\n\t\t\t\t\t\ti++;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfs[i].set(this, val >> i & (1 << c.value()) - 1);\r\n\t\t\t\t\t\ti += c.value();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\r\n\t\t\tpublic int toInt() throws Exception {\r\n\t\t\t\tField[] fs = getDeclaredFields();\r\n\t\t\t\tint ans = 0;\r\n\t\t\t\tfor (int i = 0; i < fs.length;) {\r\n\t\t\t\t\tBitCount c = fs[i].getAnnotation(BitCount.class);\r\n\t\t\t\t\tif (c == null) {\r\n\t\t\t\t\t\tif (fs[i].getBoolean(this))\r\n\t\t\t\t\t\t\tans |= 1 << i;\r\n\t\t\t\t\t\ti++;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tint val = fs[i].getInt(this);\r\n\t\t\t\t\t\tans |= val << i;\r\n\t\t\t\t\t\ti += c.value();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn ans;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class MOVEWAVE extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int speed;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int width;\r\n\t\t\t@Order(3)\r\n\t\t\tpublic int time;\r\n\t\t\t@Order(4)\r\n\t\t\tpublic int dis;\r\n\t\t\t@Order(5)\r\n\t\t\tpublic int itv;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class PM extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int mult;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class POISON extends ProcItem {\r\n\r\n\t\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\t\tpublic static class TYPE extends IntType {\r\n\t\t\t\t@BitCount(2)\r\n\t\t\t\t@Order(0)\r\n\t\t\t\tpublic int damage_type;\r\n\t\t\t\t@Order(1)\r\n\t\t\t\tpublic boolean unstackable;\r\n\t\t\t\t@Order(2)\r\n\t\t\t\tpublic boolean ignoreMetal;\r\n\t\t\t\t@Order(3)\r\n\t\t\t\tpublic boolean modifAffected;\r\n\t\t\t}\r\n\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int time;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int damage;\r\n\t\t\t@Order(3)\r\n\t\t\tpublic int itv;\r\n\t\t\t@Order(4)\r\n\t\t\tpublic TYPE type = new TYPE();\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class PROB extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class MULT extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int mult;\r\n\t\t}\r\n\r\n\t\tpublic static abstract class ProcItem implements Cloneable, BattleStatic {\r\n\t\t\tpublic ProcItem clear() {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tField[] fs = getDeclaredFields();\r\n\t\t\t\t\tfor (Field f : fs)\r\n\t\t\t\t\t\tif (f.getType() == int.class)\r\n\t\t\t\t\t\t\tf.set(this, 0);\r\n\t\t\t\t\t\telse if (IntType.class.isAssignableFrom(f.getType()))\r\n\t\t\t\t\t\t\tf.set(this, (f.getType().newInstance()));\r\n\t\t\t\t\t\telse if (f.getType() == Identifier.class)\r\n\t\t\t\t\t\t\tf.set(this, null);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tthrow new Exception(\"unknown field \" + f.getType() + \" \" + f.getName());\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic ProcItem clone() {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tProcItem ans = (ProcItem) super.clone();\r\n\t\t\t\t\tField[] fs = getDeclaredFields();\r\n\t\t\t\t\tfor (Field f : fs)\r\n\t\t\t\t\t\tif (IntType.class.isAssignableFrom(f.getType()) && f.get(this) != null) {\r\n\t\t\t\t\t\t\tf.set(ans, ((IntType) f.get(this)).clone());\r\n\t\t\t\t\t\t} else if (f.getType() == Identifier.class && f.get(this) != null)\r\n\t\t\t\t\t\t\tf.set(ans, ((Identifier<?>) f.get(this)).clone());\r\n\t\t\t\t\treturn ans;\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpublic boolean exists() {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tField[] fs = getDeclaredFields();\r\n\t\t\t\t\tfor (Field f : fs)\r\n\t\t\t\t\t\tif (f.getType() == int.class) {\r\n\t\t\t\t\t\t\tObject o = f.get(this);\r\n\r\n\t\t\t\t\t\t\tif(f.getName().equals(\"prob\") && ((Integer) o) == 0)\r\n\t\t\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t\t\tif (((Integer) o) != 0)\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (((IntType) f.get(this)).toInt() > 0)\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Deprecated\r\n\t\t\tpublic int get(int i) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tField f = getDeclaredFields()[i];\r\n\t\t\t\t\treturn f.getType() == int.class ? f.getInt(this) : ((IntType) f.get(this)).toInt();\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpublic Field[] getDeclaredFields() {\r\n\t\t\t\treturn FieldOrder.getDeclaredFields(this.getClass());\r\n\t\t\t}\r\n\r\n\t\t\t@Deprecated\r\n\t\t\tpublic ProcItem load(int[] data) throws Exception {\r\n\t\t\t\tField[] fs = getDeclaredFields();\r\n\t\t\t\tfor (int i = 0; i < Math.min(data.length, fs.length); i++)\r\n\t\t\t\t\tif (fs[i].getType() == int.class)\r\n\t\t\t\t\t\tfs[i].set(this, data[i]);\r\n\t\t\t\t\telse if (IntType.class.isAssignableFrom(fs[i].getType()))\r\n\t\t\t\t\t\tfs[i].set(this, ((IntType) fs[i].getType().newInstance()).load(data[i]));\r\n\t\t\t\t\telse if (fs[i].getType() == Identifier.class)\r\n\t\t\t\t\t\tfs[i].set(this, Identifier.parseIntRaw(data[i], this.getClass()));\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tthrow new Exception(\"unknown field \" + fs[i].getType() + \" \" + fs[i].getName());\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\r\n\t\t\tpublic boolean perform(CopRand r) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tField f = this.getClass().getDeclaredField(\"prob\");\r\n\t\t\t\t\tint prob = f.getInt(this);\r\n\t\t\t\t\tif (prob == 0)\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\tif (prob == 100)\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\treturn r.nextDouble() * 100 < prob;\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\treturn exists();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**\r\n\t\t\t * should not modify IntType and Identifier\r\n\t\t\t */\r\n\t\t\t@Deprecated\r\n\t\t\tpublic void set(int i, int v) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tField f = getDeclaredFields()[i];\r\n\t\t\t\t\tif (f.getType() == int.class)\r\n\t\t\t\t\t\tf.set(this, v);\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpublic void set(ProcItem pi) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tField[] fs = getDeclaredFields();\r\n\t\t\t\t\tfor (Field f : fs)\r\n\t\t\t\t\t\tif (f.getType().isPrimitive())\r\n\t\t\t\t\t\t\tf.set(this, f.get(pi));\r\n\t\t\t\t\t\telse if (IntType.class.isAssignableFrom(f.getType()))\r\n\t\t\t\t\t\t\tf.set(this, ((IntType) f.get(pi)).clone());\r\n\t\t\t\t\t\telse if (f.getType() == Identifier.class) {\r\n\t\t\t\t\t\t\tIdentifier<?> id = (Identifier<?>) f.get(pi);\r\n\t\t\t\t\t\t\tf.set(this, id == null ? null : id.clone());\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tthrow new Exception(\"unknown field \" + f.getType() + \" \" + f.getName());\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic String toString() {\r\n\t\t\t\treturn JsonEncoder.encode(this).toString();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class PT extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int time;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class PTD extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int time;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int dis;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class REVIVE extends ProcItem {\r\n\r\n\t\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\t\tpublic static class TYPE extends IntType {\r\n\t\t\t\t@BitCount(2)\r\n\t\t\t\t@Order(0)\r\n\t\t\t\tpublic int range_type;\r\n\t\t\t\t@Order(1)\r\n\t\t\t\tpublic boolean imu_zkill;\r\n\t\t\t\t@Order(2)\r\n\t\t\t\tpublic boolean revive_non_zombie;\r\n\t\t\t\t@Order(3)\r\n\t\t\t\tpublic boolean revive_others;\r\n\t\t\t}\r\n\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int count;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int time;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int health;\r\n\t\t\t@Order(3)\r\n\t\t\tpublic int dis_0;\r\n\t\t\t@Order(4)\r\n\t\t\tpublic int dis_1;\r\n\t\t\t@Order(5)\r\n\t\t\tpublic TYPE type = new TYPE();\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD) // Starred Barrier\r\n\t\tpublic static class BARRIER extends ProcItem {\r\n\r\n\t\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\t\tpublic static class TYPE extends IntType {\r\n\t\t\t\t@Order(0)\r\n\t\t\t\tpublic boolean magnif;\r\n\t\t\t}\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int health;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int regentime;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int timeout;\r\n\t\t\t@Order(3)\r\n\t\t\tpublic TYPE type = new TYPE();\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class SPEED extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int time;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int speed;\r\n\t\t\t@Order(3)\r\n\t\t\tpublic int type;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class STRONG extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int health;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int mult;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class SUMMON extends ProcItem {\r\n\r\n\t\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\t\tpublic static class TYPE extends IntType {\r\n\r\n\t\t\t\t@BitCount(2)\r\n\t\t\t\t@Order(0)\r\n\t\t\t\tpublic int anim_type;\r\n\t\t\t\t@Order(1)\r\n\t\t\t\tpublic boolean ignore_limit;\r\n\t\t\t\t@Order(2)\r\n\t\t\t\tpublic boolean fix_buff;\r\n\t\t\t\t@Order(3)\r\n\t\t\t\tpublic boolean same_health;\r\n\t\t\t\t@Order(4)\r\n\t\t\t\tpublic boolean random_layer;\r\n\t\t\t\t@Order(5)\r\n\t\t\t\tpublic boolean on_hit;\r\n\t\t\t\t@Order(6)\r\n\t\t\t\tpublic boolean on_kill;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic Identifier<?> id;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int dis;\r\n\t\t\t@Order(3)\r\n\t\t\tpublic int mult;\r\n\t\t\t@Order(4)\r\n\t\t\tpublic TYPE type = new TYPE();\r\n\t\t\t@Order(5)\r\n\t\t\tpublic int time;\r\n\t\t\t@Order(6)\r\n\t\t\tpublic int form;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class THEME extends ProcItem {\r\n\r\n\t\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\t\tpublic static class TYPE extends IntType {\r\n\t\t\t\t@Order(0)\r\n\t\t\t\tpublic boolean kill;\r\n\t\t\t}\r\n\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int time;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic Identifier<Background> id;\r\n\t\t\t@Order(3)\r\n\t\t\tpublic Identifier<Music> mus;\r\n\t\t\t@Order(4)\r\n\t\t\tpublic TYPE type = new TYPE();\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class COUNTER extends ProcItem {\r\n\r\n\t\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\t\tpublic static class TYPE extends IntType {\r\n\t\t\t\t@BitCount(2)\r\n\t\t\t\t@Order(0)\r\n\t\t\t\tpublic int counterWave;\r\n\t\t\t\t@BitCount(2)\r\n\t\t\t\t@Order(1)\r\n\t\t\t\tpublic int procType;\r\n\t\t\t\t@Order(1)\r\n\t\t\t\tpublic boolean useOwnDamage;\r\n\t\t\t\t@Order(2)\r\n\t\t\t\tpublic boolean outRange;\r\n\t\t\t\t@Order(3)\r\n\t\t\t\tpublic boolean areaAttack;\r\n\t\t\t}\r\n\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int damage;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int minRange;\r\n\t\t\t@Order(3)\r\n\t\t\tpublic int maxRange;\r\n\t\t\t@Order(4)\r\n\t\t\tpublic TYPE type = new TYPE();\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class VOLC extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int dis_0;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int dis_1;\r\n\t\t\t@Order(3)\r\n\t\t\tpublic int time;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class WAVE extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int lv;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class MINIWAVE extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int lv;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int multi;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD) //Used for procs that lack the block reformat\r\n\t\tpublic static class WAVEI extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int mult;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class CANNI extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int mult;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int type;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class WEAK extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int time;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int mult;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class DSHIELD extends ProcItem {\r\n\t\t\t@Order(0)\r\n\t\t\tpublic int hp;\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int regen;\r\n\t\t}\r\n\r\n\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\tpublic static class BSTHUNT extends ProcItem {\r\n\t\t\t@JsonClass(noTag = NoTag.LOAD)\r\n\t\t\tpublic static class TYPE extends IntType {\r\n\t\t\t\t@Order(0)\r\n\t\t\t\tpublic boolean active;\r\n\t\t\t}\r\n\t\t\t@Order(0)\r\n\t\t\tpublic TYPE type = new TYPE();\r\n\t\t\t@Order(1)\r\n\t\t\tpublic int prob;\r\n\t\t\t@Order(2)\r\n\t\t\tpublic int time;\r\n\t\t}\r\n\r\n\t\tpublic static Proc blank() {\r\n\t\t\treturn new Proc();\r\n\t\t}\r\n\r\n\t\tpublic static Field[] getDeclaredFields() {\r\n\t\t\treturn FieldOrder.getDeclaredFields(Proc.class);\r\n\t\t}\r\n\r\n\t\tpublic static String getName(int i) {\r\n\t\t\treturn getDeclaredFields()[i].getName();\r\n\t\t}\r\n\r\n\t\tpublic static Proc load(int[][] data) {\r\n\t\t\tProc ans = new Proc();\r\n\t\t\ttry {\r\n\t\t\t\tField[] fs = getDeclaredFields();\r\n\t\t\t\tfor (int i = 0; i < fs.length; i++) {\r\n\t\t\t\t\tfs[i].setAccessible(true);\r\n\r\n\t\t\t\t\tif(i < data.length) {\r\n\t\t\t\t\t\tfs[i].set(ans, ((ProcItem) fs[i].getType().newInstance()).load(data[i]));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfs[i].set(ans, ((ProcItem) fs[i].getType().newInstance()).clear());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t\treturn ans;\r\n\t\t}\r\n\r\n\t\t@Order(0)\r\n\t\tpublic final PTD KB = new PTD();\r\n\t\t@Order(1)\r\n\t\tpublic final PT STOP = new PT();\r\n\t\t@Order(2)\r\n\t\tpublic final PT SLOW = new PT();\r\n\t\t@Order(3)\r\n\t\tpublic final PM CRIT = new PM();\r\n\t\t@Order(4)\r\n\t\tpublic final WAVE WAVE = new WAVE();\r\n\t\t@Order(5)\r\n\t\tpublic final MINIWAVE MINIWAVE = new MINIWAVE();\r\n\t\t@Order(6)\r\n\t\tpublic final MOVEWAVE MOVEWAVE = new MOVEWAVE();\r\n\t\t@Order(7)\r\n\t\tpublic final VOLC VOLC = new VOLC();\r\n\t\t@Order(8)\r\n\t\tpublic final WEAK WEAK = new WEAK();\r\n\t\t@Order(9)\r\n\t\tpublic final PROB BREAK = new PROB();\r\n\t\t@Order(10)\r\n\t\tpublic final PROB SHIELDBREAK = new PROB();\r\n\t\t@Order(11)\r\n\t\tpublic final PTD WARP = new PTD();\r\n\t\t@Order(12)\r\n\t\tpublic final PT CURSE = new PT();\r\n\t\t@Order(13)\r\n\t\tpublic final PT SEAL = new PT();\r\n\t\t@Order(14)\r\n\t\tpublic final SUMMON SUMMON = new SUMMON();\r\n\t\t@Order(15)\r\n\t\tpublic final PT TIME = new PT();\r\n\t\t@Order(16)\r\n\t\tpublic final PROB SNIPER = new PROB();\r\n\t\t@Order(17)\r\n\t\tpublic final THEME THEME = new THEME();\r\n\t\t@Order(18)\r\n\t\tpublic final PROB BOSS = new PROB();\r\n\t\t@Order(19)\r\n\t\tpublic final POISON POISON = new POISON();\r\n\t\t@Order(20)\r\n\t\tpublic final PM SATK = new PM();\r\n\t\t@Order(21)\r\n\t\tpublic final PM POIATK = new PM();\r\n\t\t@Order(22)\r\n\t\tpublic final ARMOR ARMOR = new ARMOR();\r\n\t\t@Order(23)\r\n\t\tpublic final SPEED SPEED = new SPEED();\r\n\t\t@Order(24)\r\n\t\tpublic final STRONG STRONG = new STRONG();\r\n\t\t@Order(25)\r\n\t\tpublic final PROB LETHAL = new PROB();\r\n\t\t@Order(26)\r\n\t\tpublic final IMU IMUKB = new IMU();\r\n\t\t@Order(27)\r\n\t\tpublic final IMU IMUSTOP = new IMU();\r\n\t\t@Order(28)\r\n\t\tpublic final IMU IMUSLOW = new IMU();\r\n\t\t@Order(29)\r\n\t\tpublic final WAVEI IMUWAVE = new WAVEI();\r\n\t\t@Order(30)\r\n\t\tpublic final WAVEI IMUVOLC = new WAVEI();\r\n\t\t@Order(31)\r\n\t\tpublic final IMUAD IMUWEAK = new IMUAD();\r\n\t\t@Order(32)\r\n\t\tpublic final IMU IMUWARP = new IMU();\r\n\t\t@Order(33)\r\n\t\tpublic final IMU IMUCURSE = new IMU();\r\n\t\t@Order(34)\r\n\t\tpublic final IMU IMUSEAL = new IMU();\r\n\t\t@Order(35)\r\n\t\tpublic final IMU IMUSUMMON = new IMU();\r\n\t\t@Order(36)\r\n\t\tpublic final IMUAD IMUPOI = new IMUAD();\r\n\t\t@Order(37)\r\n\t\tpublic final IMU IMUPOIATK = new IMU();\r\n\t\t@Order(38)\r\n\t\tpublic final WAVEI IMUMOVING = new WAVEI();\r\n\t\t@Order(39)\r\n\t\tpublic final CANNI IMUCANNON = new CANNI();\r\n\t\t@Order(40)\r\n\t\tpublic final IMUAD IMUARMOR = new IMUAD();\r\n\t\t@Order(41)\r\n\t\tpublic final IMUAD IMUSPEED = new IMUAD();\r\n\t\t@Order(42)\r\n\t\tpublic final IMU CRITI = new IMU();\r\n\t\t@Order(43)\r\n\t\tpublic final COUNTER COUNTER = new COUNTER();\r\n\t\t@Order(44)\r\n\t\tpublic final PT IMUATK = new PT();\r\n\t\t@Order(45)\r\n\t\tpublic final DMGCUT DMGCUT = new DMGCUT();\r\n\t\t@Order(46)\r\n\t\tpublic final DMGCAP DMGCAP = new DMGCAP();\r\n\t\t@Order(47)\r\n\t\tpublic final BURROW BURROW = new BURROW();\r\n\t\t@Order(48)\r\n\t\tpublic final REVIVE REVIVE = new REVIVE();\r\n\t\t@Order(49)\r\n\t\tpublic final BARRIER BARRIER = new BARRIER();\r\n\t\t@Order(50)\r\n\t\tpublic final DSHIELD DEMONSHIELD = new DSHIELD();\r\n\t\t@Order(51)\r\n        public final VOLC DEATHSURGE = new VOLC();\r\n\t\t@Order(52)\r\n\t\tpublic final MULT BOUNTY = new MULT();\r\n\t\t@Order(53)\r\n\t\tpublic final MULT ATKBASE = new MULT();\r\n\t\t@Order(54)\r\n\t\tpublic final BSTHUNT BSTHUNT = new BSTHUNT(); //Unsure what does the 1st param of beast killer do, so this is temporary\r\n\r\n\t\t@Override\r\n\t\tpublic Proc clone() {\r\n\t\t\ttry {\r\n\t\t\t\tProc ans = new Proc();\r\n\t\t\t\tField[] fs = getDeclaredFields();\r\n\t\t\t\tfor (Field f : fs) {\r\n\t\t\t\t\tf.setAccessible(true);\r\n\t\t\t\t\tif(f.get(this) != null)\r\n\t\t\t\t\t\tf.set(ans, ((ProcItem) f.get(this)).clone());\r\n\t\t\t\t\tf.setAccessible(false);\r\n\t\t\t\t}\r\n\t\t\t\treturn ans;\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic ProcItem get(String id) {\r\n\t\t\ttry {\r\n\t\t\t\treturn (ProcItem) Proc.class.getField(id).get(this);\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic ProcItem getArr(int i) {\r\n\t\t\ttry {\r\n\t\t\t\treturn (ProcItem) getDeclaredFields()[i].get(this);\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic boolean sharable(int i) {\r\n\t\t\tif(i >= procSharable.length) {\r\n\t\t\t\tSystem.out.println(\"Warning : \"+i+\" is out of index of procSharable\");\r\n\t\t\t\treturn false;\r\n\t\t\t} else {\r\n\t\t\t\treturn procSharable[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String toString() {\r\n\t\t\treturn JsonEncoder.encode(this).toString();\r\n\t\t}\r\n\r\n\t\tpublic JsonObject serProc() {\r\n\t\t\tJsonObject obj = new JsonObject();\r\n\r\n\t\t\tfor(Field f : getDeclaredFields()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tString tag = f.getName();\r\n\t\t\t\t\tProcItem proc = (ProcItem) f.get(this);\r\n\r\n\t\t\t\t\tif(proc.exists()) {\r\n\t\t\t\t\t\tobj.add(tag, JsonEncoder.encode(proc));\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (IllegalAccessException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn obj;\r\n\t\t}\r\n\r\n\t\tpublic static Proc genProc(JsonElement elem) {\r\n\t\t\tProc proc = Proc.blank();\r\n\r\n\t\t\tif(elem == null)\r\n\t\t\t\treturn proc;\r\n\r\n\t\t\tJsonObject obj = elem.getAsJsonObject();\r\n\r\n\t\t\tif(obj == null)\r\n\t\t\t\treturn proc;\r\n\r\n\t\t\tfor(Field f : getDeclaredFields()) {\r\n\t\t\t\tString tag = f.getName();\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif(obj.has(tag) && !obj.get(tag).isJsonNull()) {\r\n\t\t\t\t\t\tf.setAccessible(true);\r\n\r\n\t\t\t\t\t\tf.set(proc, JsonDecoder.decode(obj.get(tag), f.getType()));\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn proc;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tpublic static final byte restrict_name = 32;\r\n\tpublic static final byte SE_VICTORY = 8;\r\n\tpublic static final byte SE_DEFEAT = 9;\r\n\tpublic static final byte SE_HIT_0 = 20;\r\n\tpublic static final byte SE_HIT_1 = 21;\r\n\tpublic static final byte SE_DEATH_0 = 23;\r\n\tpublic static final byte SE_DEATH_1 = 24;\r\n\tpublic static final byte SE_HIT_BASE = 22;\r\n\tpublic static final byte SE_ZKILL = 59;\r\n\tpublic static final byte SE_CRIT = 44;\r\n\tpublic static final byte SE_SATK = 90;\r\n\tpublic static final byte SE_WAVE = 26;\r\n\tpublic static final byte SE_LETHAL = 50;\r\n\tpublic static final byte SE_WARP_ENTER = 73;\r\n\tpublic static final byte SE_WARP_EXIT = 74;\r\n\tpublic static final byte SE_BOSS = 45;\r\n\tpublic static final byte SE_SPEND_FAIL = 15;\r\n\tpublic static final byte SE_SPEND_SUC = 19;\r\n\tpublic static final byte SE_SPEND_REF = 27;\r\n\tpublic static final byte SE_CANNON_CHARGE = 28;\r\n\tpublic static final byte SE_BARRIER_ABI = 70;\r\n\tpublic static final byte SE_BARRIER_NON = 71;\r\n\tpublic static final byte SE_BARRIER_ATK = 72;\r\n\tpublic static final byte SE_POISON = 110;\r\n\tpublic static final byte SE_VOLC_START = 111;\r\n\tpublic static final byte SE_VOLC_LOOP = 112;\r\n\tpublic static final short SE_SHIELD_HIT = 136;\r\n\tpublic static final short SE_SHIELD_BROKEN = 137;\r\n\tpublic static final short SE_SHIELD_REGEN = 138;\r\n\tpublic static final short SE_SHIELD_BREAKER = 139;\r\n\tpublic static final short SE_DEATH_SURGE = 143;\r\n\r\n\tpublic static final int[][] SE_CANNON = { { 25, 26 }, { 60 }, { 61 }, { 36, 37 }, { 65, 83 }, { 84, 85 }, { 86 },\r\n\t\t\t{ 124 } };\r\n\r\n\tpublic static final int[] SE_ALL = { 15, 19, 20, 21, 22, 23, 24, 25, 26, 27, 36, 37, 44, 45, 50, 59, 60, 61, 65, 73,\r\n\t\t\t74, 83, 84, 85, 86, 90, 110, 111, 112, 124 };\r\n\r\n\tpublic static final byte RARITY_TOT = 6;\r\n\r\n\t// trait bit filter\r\n\tpublic static final byte TB_RED = 1;\r\n\tpublic static final byte TB_FLOAT = 2;\r\n\tpublic static final byte TB_BLACK = 4;\r\n\tpublic static final byte TB_METAL = 8;\r\n\tpublic static final byte TB_ANGEL = 16;\r\n\tpublic static final byte TB_ALIEN = 32;\r\n\tpublic static final byte TB_ZOMBIE = 64;\r\n\tpublic static final short TB_RELIC = 128;\r\n\tpublic static final short TB_WHITE = 256;\r\n\tpublic static final short TB_EVA = 512;\r\n\tpublic static final short TB_WITCH = 1024;\r\n\tpublic static final short TB_INFH = 2048;\r\n\tpublic static final short TB_DEMON = 4096;\r\n\r\n\t// trait index\r\n\tpublic static final byte TRAIT_RED = 0;\r\n\tpublic static final byte TRAIT_FLOAT = 1;\r\n\tpublic static final byte TRAIT_BLACK = 2;\r\n\tpublic static final byte TRAIT_METAL = 3;\r\n\tpublic static final byte TRAIT_ANGEL = 4;\r\n\tpublic static final byte TRAIT_ALIEN = 5;\r\n\tpublic static final byte TRAIT_ZOMBIE = 6;\r\n\tpublic static final byte TRAIT_DEMON = 7;\r\n\tpublic static final byte TRAIT_RELIC = 8;\r\n\tpublic static final byte TRAIT_WHITE = 9;\r\n\tpublic static final byte TRAIT_EVA = 10;\r\n\tpublic static final byte TRAIT_WITCH = 11;\r\n\tpublic static final byte TRAIT_BARON = 12;\r\n\tpublic static final byte TRAIT_BEAST = 13;\r\n\tpublic static final byte TRAIT_INFH = 14;\r\n\tpublic static final byte TRAIT_TOT = 15;\r\n\r\n\t// treasure\r\n\tpublic static final byte T_RED = 0;\r\n\tpublic static final byte T_FLOAT = 1;\r\n\tpublic static final byte T_BLACK = 2;\r\n\tpublic static final byte T_ANGEL = 3;\r\n\tpublic static final byte T_METAL = 4;\r\n\tpublic static final byte T_ALIEN = 5;\r\n\tpublic static final byte T_ZOMBIE = 6;\r\n\r\n\t// default tech value\r\n\tpublic static final int[] MLV = new int[] { 30, 30, 30, 30, 30, 30, 30, 10, 30 };\r\n\r\n\t// tech index\r\n\tpublic static final byte LV_RES = 0;\r\n\tpublic static final byte LV_ACC = 1;\r\n\tpublic static final byte LV_BASE = 2;\r\n\tpublic static final byte LV_WORK = 3;\r\n\tpublic static final byte LV_WALT = 4;\r\n\tpublic static final byte LV_RECH = 5;\r\n\tpublic static final byte LV_CATK = 6;\r\n\tpublic static final byte LV_CRG = 7;\r\n\tpublic static final byte LV_XP = 8;\r\n\tpublic static final byte LV_TOT = 9;\r\n\r\n\t// default treasure value\r\n\tpublic static final int[] MT = new int[] { 300, 300, 300, 300, 300, 300, 600, 600, 600, 300, 300 };\r\n\r\n\t// treasure index\r\n\tpublic static final byte T_ATK = 0;\r\n\tpublic static final byte T_DEF = 1;\r\n\tpublic static final byte T_RES = 2;\r\n\tpublic static final byte T_ACC = 3;\r\n\tpublic static final byte T_WORK = 4;\r\n\tpublic static final byte T_WALT = 5;\r\n\tpublic static final byte T_RECH = 6;\r\n\tpublic static final byte T_CATK = 7;\r\n\tpublic static final byte T_BASE = 8;\r\n\tpublic static final byte T_XP1 = 9;\r\n\tpublic static final byte T_XP2 = 10;\r\n\tpublic static final byte T_TOT = 11;\r\n\r\n\t// abi bit filter\r\n\tpublic static final int AB_GOOD = 1;\r\n\tpublic static final int AB_RESIST = 1 << 1;\r\n\tpublic static final int AB_MASSIVE = 1 << 2;\r\n\tpublic static final int AB_ONLY = 1 << 3;\r\n\tpublic static final int AB_METALIC = 1 << 4;\r\n\tpublic static final int AB_WAVES = 1 << 5;\r\n\tpublic static final int AB_SNIPERI = 1 << 6;\r\n\tpublic static final int AB_TIMEI = 1 << 7;\r\n\tpublic static final int AB_GHOST = 1 << 8;\r\n\tpublic static final int AB_ZKILL = 1 << 9;\r\n\tpublic static final int AB_WKILL = 1 << 10;\r\n\tpublic static final int AB_GLASS = 1 << 11;\r\n\tpublic static final int AB_THEMEI = 1 << 12;\r\n\tpublic static final int AB_EKILL = 1 << 13;\r\n\tpublic static final int AB_IMUSW = 1 << 14;\r\n\tpublic static final int AB_RESISTS = 1 << 15;\r\n\tpublic static final int AB_MASSIVES = 1 << 16;\r\n\tpublic static final int AB_BAKILL = 1 << 17;\r\n\tpublic static final int AB_CKILL = 1 << 18;\r\n\r\n\t// abi index\r\n\tpublic static final byte ABI_GOOD = 0;\r\n\tpublic static final byte ABI_RESIST = 1;\r\n\tpublic static final byte ABI_MASSIVE = 2;\r\n\tpublic static final byte ABI_ONLY = 3;\r\n\tpublic static final byte ABI_METALIC = 4;\r\n\tpublic static final byte ABI_WAVES = 5;\r\n\tpublic static final byte ABI_SNIPERI = 6;\r\n\tpublic static final byte ABI_TIMEI = 7;\r\n\tpublic static final byte ABI_GHOST = 8;\r\n\tpublic static final byte ABI_ZKILL = 9;\r\n\tpublic static final byte ABI_WKILL = 10;\r\n\tpublic static final byte ABI_GLASS = 11;\r\n\tpublic static final byte ABI_THEMEI = 12;\r\n\tpublic static final byte ABI_EKILL = 13;\r\n\tpublic static final byte ABI_IMUSW = 14;\r\n\tpublic static final byte ABI_RESISTS = 15;\r\n\tpublic static final byte ABI_MASSIVES = 16;\r\n\tpublic static final byte ABI_BAKILL = 17;\r\n\tpublic static final byte ABI_CKILL = 18;\r\n\tpublic static final byte ABI_TOT = 19;// 20 currently\r\n\r\n\t// proc index\r\n\tpublic static final int P_KB = 0;\r\n\tpublic static final int P_STOP = 1;\r\n\tpublic static final int P_SLOW = 2;\r\n\tpublic static final int P_CRIT = 3;\r\n\tpublic static final int P_WAVE = 4;\r\n\tpublic static final int P_MINIWAVE = 5;\r\n\tpublic static final int P_MOVEWAVE = 6;\r\n\tpublic static final int P_VOLC = 7;\r\n\tpublic static final int P_WEAK = 8;\r\n\tpublic static final int P_BREAK = 9;\r\n\tpublic static final int P_SHIELDBREAK = 10;\r\n\tpublic static final int P_WARP = 11;\r\n\tpublic static final int P_CURSE = 12;\r\n\tpublic static final int P_SEAL = 13;\r\n\t/**\r\n\t * 0:prob, 1:ID, 2:location, 3: buff, 4:conf, 5:time\r\n\t *\r\n\t * +0: direct, +1: warp, +2:burrow, +4:disregard limit, +8: fix buff, +16: same\r\n\t * health, +32: diff layer, +64 on hit, +128 on kill\r\n\t */\r\n\tpublic static final int P_SUMMON = 14;\r\n\t/**\r\n\t * 0:prob, 1:speed, 2:width (left to right), 3:time, 4:origin (center), 5:itv\r\n\t */\r\n\tpublic static final int P_TIME = 15;\r\n\tpublic static final int P_SNIPER = 16;\r\n\t/**\r\n\t * 0:prob, 1:time (-1 means infinite), 2:ID, 3: type 0 : Change only BG 1 : Kill\r\n\t * all and change BG\r\n\t */\r\n\tpublic static final int P_THEME = 17;\r\n\tpublic static final int P_BOSS = 18;\r\n\t/**\r\n\t * 0:prob, 1:time, 2:dmg, 3:itv, 4: conf +0: normal, +1: of total, +2: of\r\n\t * current, +3: of lost, +4: unstackable\r\n\t */\r\n\tpublic static final int P_POISON = 19;\r\n\tpublic static final int P_SATK = 20;\r\n\t/**\r\n\t * official poison\r\n\t */\r\n\tpublic static final int P_POIATK = 21;\r\n\t/**\r\n\t * Make target receive n% damage more/less 0: chance, 1: duration, 2: debuff\r\n\t */\r\n\tpublic static final int P_ARMOR = 22;\r\n\t/**\r\n\t * Make target move faster/slower 0: chance, 1: duration, 2: speed, 3: type type\r\n\t * 0: Current speed * (100 + n)% type 1: Current speed + n type 2: Fixed speed\r\n\t */\r\n\tpublic static final int P_SPEED = 23;\r\n\tpublic static final int P_STRONG = 24;\r\n\tpublic static final int P_LETHAL = 25;\r\n\tpublic static final int P_IMUKB = 26;\r\n\tpublic static final int P_IMUSTOP = 27;\r\n\tpublic static final int P_IMUSLOW = 28;\r\n\tpublic static final int P_IMUWAVE = 29;\r\n\tpublic static final int P_IMUVOLC = 30;\r\n\tpublic static final int P_IMUWEAK = 31;\r\n\tpublic static final int P_IMUWARP = 32;\r\n\tpublic static final int P_IMUCURSE = 33;\r\n\tpublic static final int P_IMUSEAL = 34;\r\n\tpublic static final int P_IMUSUMMON = 35;\r\n\tpublic static final int P_IMUPOI = 36;\r\n\tpublic static final int P_IMUPOIATK = 37;\r\n\tpublic static final int P_IMUMOVING = 38;\r\n\tpublic static final int P_IMUCANNON = 39;\r\n\tpublic static final int P_IMUARMOR = 40;\r\n\tpublic static final int P_IMUSPEED = 41;\r\n\tpublic static final int P_CRITI = 42;\r\n\tpublic static final int P_COUNTER = 43;\r\n\tpublic static final int P_IMUATK = 44;\r\n\tpublic static final int P_DMGCUT = 45;\r\n\tpublic static final int P_DMGCAP = 46;\r\n\tpublic static final int P_BURROW = 47;\r\n\t/**\r\n\t * body proc: 0: add revive time for zombies, -1 to make it infinite, revivable\r\n\t * zombies only 1: revive time 2: revive health 3: point 1 4: point 2 5: type:\r\n\t * 0/1/2/3: duration: in range and normal/in range/ master lifetime/permanent\r\n\t * +4: make Z-kill unusable +8: revive non-zombie also +16: applicapable to\r\n\t * others\r\n\t */\r\n\tpublic static final int P_REVIVE = 48;\r\n\tpublic static final int P_BARRIER = 49;\r\n\tpublic static final int P_DEMONSHIELD = 50;\r\n\tpublic static final int P_DEATHSURGE = 51;\r\n\tpublic static final int P_BOUNTY = 52;\r\n\tpublic static final int P_ATKBASE = 53;\r\n\tpublic static final int P_BSTHUNT = 54; //Beast Killer\r\n\tpublic static final byte PROC_TOT = 55;// 53\r\n\tpublic static final byte PROC_WIDTH = 6;\r\n\r\n\tpublic static final boolean[] procSharable = {\r\n\t\t\tfalse, //kb\r\n\t\t\tfalse, //freeze\r\n\t\t\tfalse, //slow\r\n\t\t\tfalse, //critical\r\n\t\t\tfalse, //wave\r\n\t\t\tfalse, //miniwave\r\n\t\t\tfalse, //move wave\r\n\t\t\tfalse, //volcano\r\n\t\t\tfalse, //weaken\r\n\t\t\tfalse, //barrier breaker\r\n\t\t\tfalse, //shield breaker\r\n\t\t\tfalse, //warp\r\n\t\t\tfalse, //curse\r\n\t\t\tfalse, //seal\r\n\t\t\tfalse, //summon\r\n\t\t\tfalse, //time\r\n\t\t\tfalse, //sniper\r\n\t\t\tfalse, //theme\r\n\t\t\tfalse, //boss wave\r\n\t\t\tfalse, //venom\r\n\t\t\tfalse, //savage blow\r\n\t\t\tfalse, //poison\r\n\t\t\tfalse, //armor\r\n\t\t\tfalse, //haste\r\n\t\t\ttrue,  //strengthen\r\n\t\t\ttrue,  //survive\r\n\t\t\ttrue,  //imu.kb\r\n\t\t\ttrue,  //imu.freeze\r\n\t\t\ttrue,  //imu.slow\r\n\t\t\ttrue,  //imu.wave\r\n\t\t\ttrue,  //imu.volcano\r\n\t\t\ttrue,  //imu.weaken\r\n\t\t\ttrue,  //imu.warp\r\n\t\t\ttrue,  //imu.curse\r\n\t\t\ttrue,  //imu.seal\r\n\t\t\ttrue,  //imu.summon\r\n\t\t\ttrue,  //imu.BCU poison\r\n\t\t\ttrue,  //imu.poison\r\n\t\t\ttrue,  //imu.moving atk\r\n\t\t\ttrue,  //imu.cannon\r\n\t\t\ttrue,  //imu.armor break\r\n\t\t\ttrue,  //imu.haste\r\n\t\t\ttrue,  //imu. critical\r\n\t\t\ttrue,  //invincibility\r\n\t\t\ttrue,  //damage cut\r\n\t\t\ttrue,  //damage cap\r\n\t\t\ttrue,  //counter\r\n\t\t\ttrue,  //burrow\r\n\t\t\ttrue,  //revive\r\n\t\t\ttrue,  //barrier\r\n\t\t\ttrue,  //demon barrier\r\n\t\t\ttrue,  //death surge\r\n\t\t\tfalse, //2x money\r\n\t\t\tfalse, //base destroyer\r\n\t\t\ttrue, //beast hunter\r\n\t};\r\n\r\n\t/**\r\n\t * Procs in here are shareable on any hit for BC entities, but not shareable for custom entities\r\n\t */\r\n\tpublic static final int[] BCShareable = { P_BOUNTY, P_ATKBASE };\r\n\r\n\t/**\r\n\t * Procs in this list are removed when an unit is hit and has a barrier or Aku shield active\r\n\t */\r\n\tpublic static final byte[] REMOVABLE_PROC = {\r\n\t\t\tP_STOP, P_SLOW, P_WEAK, P_CURSE, P_SEAL, P_POISON, P_ARMOR, P_SPEED\r\n\t};\r\n\r\n\tpublic static final byte WT_WAVE = 1;\r\n\tpublic static final byte WT_MOVE = 2;\r\n\tpublic static final byte WT_CANN = 2;\r\n\tpublic static final byte WT_VOLC = 4;\r\n\tpublic static final byte WT_MINI = 8;\r\n\tpublic static final byte PC_P = 0, PC_AB = 1, PC_BASE = 2, PC_IMU = 3, PC_TRAIT = 4;\r\n\tpublic static final byte PC2_HP = 0;\r\n\tpublic static final byte PC2_ATK = 1;\r\n\tpublic static final byte PC2_SPEED = 2;\r\n\tpublic static final byte PC2_COST = 3;\r\n\tpublic static final byte PC2_CD = 4;\r\n\tpublic static final byte PC2_HB = 5;\r\n\tpublic static final byte PC2_TOT = 6;\r\n\t// -1 for None\r\n\t// 0 for Proc\r\n\t// 1 for Ability\r\n\t// 2 for Base stat\r\n\t// 3 for Immune\r\n\t// 4 for Trait\r\n\tpublic static final int[][] PC_CORRES = new int[][] { // NP value table\r\n\t\t\t{ -1, 0 }, // 0:\r\n\t\t\t{ 0, P_WEAK }, // 1: weak, reversed health or relic-weak\r\n\t\t\t{ 0, P_STOP }, // 2: stop\r\n\t\t\t{ 0, P_SLOW }, // 3: slow\r\n\t\t\t{ 1, AB_ONLY, 0 }, // 4:\r\n\t\t\t{ 1, AB_GOOD, 0 }, // 5:\r\n\t\t\t{ 1, AB_RESIST, 0 }, // 6:\r\n\t\t\t{ 1, AB_MASSIVE, 0 }, // 7:\r\n\t\t\t{ 0, P_KB }, // 8: kb\r\n\t\t\t{ 0, P_WARP, 0 }, // 9:\r\n\t\t\t{ 0, P_STRONG }, // 10: berserker, reversed health\r\n\t\t\t{ 0, P_LETHAL }, // 11: lethal\r\n\t\t\t{ 0, P_ATKBASE, 0 }, // 12: Base Destroyer\r\n\t\t\t{ 0, P_CRIT }, // 13: crit\r\n\t\t\t{ 1, AB_ZKILL }, // 14: zkill\r\n\t\t\t{ 0, P_BREAK }, // 15: break\r\n\t\t\t{ 0, P_BOUNTY }, // 16: 2x income\r\n\t\t\t{ 0, P_WAVE }, // 17: wave\r\n\t\t\t{ 0, P_IMUWEAK }, // 18: res weak\r\n\t\t\t{ 0, P_IMUSTOP }, // 19: res stop\r\n\t\t\t{ 0, P_IMUSLOW }, // 20: res slow\r\n\t\t\t{ 0, P_IMUKB }, // 21: res kb\r\n\t\t\t{ 0, P_IMUWAVE }, // 22: res wave\r\n\t\t\t{ 1, AB_WAVES, 0 }, // 23: waveblock\r\n\t\t\t{ 0, P_IMUWARP, 0 }, // 24: res warp\r\n\t\t\t{ 2, PC2_COST }, // 25: reduce cost\r\n\t\t\t{ 2, PC2_CD }, // 26: reduce cooldown\r\n\t\t\t{ 2, PC2_SPEED }, // 27: inc speed\r\n\t\t\t{ 2, PC2_HB }, // 28: inc knockbacks\r\n\t\t\t{ 3, P_IMUCURSE }, // 29: imu curse\r\n\t\t\t{ 0, P_IMUCURSE }, // 30: res curse\r\n\t\t\t{ 2, PC2_ATK }, // 31: inc ATK\r\n\t\t\t{ 2, PC2_HP }, // 32: inc HP\r\n\t\t\t{ 4, TRAIT_RED, 0 }, // 33: targeting red\r\n\t\t\t{ 4, TRAIT_FLOAT, 0 }, // 34: targeting floating\r\n\t\t\t{ 4, TRAIT_BLACK, 0 }, // 35: targeting black\r\n\t\t\t{ 4, TRAIT_METAL, 0 }, // 36: targeting metal\r\n\t\t\t{ 4, TRAIT_ANGEL, 0 }, // 37: targeting angel\r\n\t\t\t{ 4, TRAIT_ALIEN, 0 }, // 38: targeting alien\r\n\t\t\t{ 4, TRAIT_ZOMBIE, 0 }, // 39: targeting zombie\r\n\t\t\t{ 4, TRAIT_RELIC, 0 }, // 40: targeting relic\r\n\t\t\t{ 4, TRAIT_WHITE, 0 }, // 41: targeting white\r\n\t\t\t{ -1, 0 }, // 42:\r\n\t\t\t{ -1, 0 }, // 43:\r\n\t\t\t{ 3, P_IMUWEAK }, // 44: immune to weak\r\n\t\t\t{ 3, P_IMUSTOP }, // 45: immune to freeze\r\n\t\t\t{ 3, P_IMUSLOW }, // 46: immune to slow\r\n\t\t\t{ 3, P_IMUKB }, // 47: immune to kb\r\n\t\t\t{ 3, P_IMUWAVE }, // 48: immune to wave\r\n\t\t\t{ 3, P_IMUWARP }, // 49: immune to warp\r\n\t\t\t{ 0, P_SATK }, // 50: savage blow\r\n\t\t\t{ 0, P_IMUATK }, // 51: immune to attack\r\n\t\t\t{ 0, P_IMUPOIATK }, // 52: resist to poison ?\r\n\t\t\t{ 3, P_IMUPOIATK }, // 53: immune to poison\r\n\t\t\t{ 0, P_IMUVOLC }, // 54: resist to surge ?\r\n\t\t\t{ 3, P_IMUVOLC }, // 55: immune to surge\r\n\t\t\t{ 0, P_VOLC }, // 56: surge, level up to chance up\r\n\t\t\t{ 4, TRAIT_DEMON, 0 }, // 57: Targetting Aku\r\n\t\t\t{ 0, P_SHIELDBREAK }, //58 : shield piercing\r\n\t\t\t{ 1, AB_CKILL }, //59 : corpse killer\r\n\t\t\t{ 0, P_CURSE } //60 : curse\r\n\t};\r\n\r\n\t// foot icon index used in battle\r\n\tpublic static final byte INV = -1;\r\n\tpublic static final byte INVWARP = -2;\r\n\tpublic static final byte STPWAVE = -3;\r\n\tpublic static final byte BREAK_ABI = -4;\r\n\tpublic static final byte BREAK_ATK = -5;\r\n\tpublic static final byte BREAK_NON = -6;\r\n\tpublic static final byte HEAL = -7;\r\n\tpublic static final byte SHIELD_HIT = -8;\r\n\tpublic static final byte SHIELD_BROKEN = -9;\r\n\tpublic static final byte SHIELD_REGEN = -10;\r\n\tpublic static final byte SHIELD_BREAKER = -11;\r\n\tpublic static final byte DMGCAP_FAIL = -12;\r\n\tpublic static final byte DMGCAP_SUCCESS = -13;\r\n\r\n\t// Combo index\r\n\tpublic static final byte C_ATK = 0;\r\n\tpublic static final byte C_DEF = 1;\r\n\tpublic static final byte C_SPE = 2;\r\n\tpublic static final byte C_GOOD = 14;\r\n\tpublic static final byte C_MASSIVE = 15;\r\n\tpublic static final byte C_RESIST = 16;\r\n\tpublic static final byte C_KB = 17;\r\n\tpublic static final byte C_SLOW = 18;\r\n\tpublic static final byte C_STOP = 19;\r\n\tpublic static final byte C_WEAK = 20;\r\n\tpublic static final byte C_STRONG = 21;\r\n\tpublic static final byte C_WKILL = 22;\r\n\tpublic static final byte C_EKILL = 23;\r\n\tpublic static final byte C_CRIT = 24;\r\n\tpublic static final byte C_C_INI = 3;\r\n\tpublic static final byte C_C_ATK = 6;\r\n\tpublic static final byte C_C_SPE = 7;\r\n\tpublic static final byte C_BASE = 10;\r\n\tpublic static final byte C_M_INI = 5;\r\n\tpublic static final byte C_M_LV = 4;\r\n\tpublic static final byte C_M_INC = 8;\r\n\tpublic static final byte C_M_MAX = 9;\r\n\tpublic static final byte C_RESP = 11;\r\n\tpublic static final byte C_MEAR = 12;\r\n\tpublic static final byte C_XP = 13;// abandoned\r\n\tpublic static final byte C_TOT = 25;\r\n\r\n\t// Effects Anim index\r\n\tpublic static final byte A_KB = 29;\r\n\tpublic static final byte A_CRIT = 28;\r\n\tpublic static final byte A_SHOCKWAVE = 27;\r\n\tpublic static final byte A_ZOMBIE = 26;\r\n\tpublic static final byte A_EFF_INV = 18;\r\n\tpublic static final byte A_EFF_DEF = 19;// unused\r\n\tpublic static final byte A_Z_STRONG = 20;\r\n\tpublic static final byte A_B = 21;\r\n\tpublic static final byte A_E_B = 22;\r\n\tpublic static final byte A_W = 23;\r\n\tpublic static final byte A_W_C = 24;\r\n\tpublic static final byte A_CURSE = 25;\r\n\tpublic static final byte A_DOWN = 0;\r\n\tpublic static final byte A_UP = 2;\r\n\tpublic static final byte A_SLOW = 4;\r\n\tpublic static final byte A_STOP = 6;\r\n\tpublic static final byte A_SHIELD = 8;\r\n\tpublic static final byte A_FARATTACK = 10;\r\n\tpublic static final byte A_WAVE_INVALID = 12;\r\n\tpublic static final byte A_WAVE_STOP = 14;\r\n\tpublic static final byte A_WAVEGUARD = 16;// unused\r\n\tpublic static final byte A_E_DOWN = 1;\r\n\tpublic static final byte A_E_UP = 3;\r\n\tpublic static final byte A_E_SLOW = 5;\r\n\tpublic static final byte A_E_STOP = 7;\r\n\tpublic static final byte A_E_SHIELD = 9;\r\n\tpublic static final byte A_E_FARATTACK = 11;\r\n\tpublic static final byte A_E_WAVE_INVALID = 13;\r\n\tpublic static final byte A_E_WAVE_STOP = 15;\r\n\tpublic static final byte A_E_WAVEGUARD = 17;// unused\r\n\tpublic static final byte A_SNIPER = 30;\r\n\tpublic static final byte A_U_ZOMBIE = 31;\r\n\tpublic static final byte A_SEAL = 32;\r\n\tpublic static final byte A_E_SEAL = 33;\r\n\tpublic static final byte A_POI0 = 34;\r\n\tpublic static final byte A_POI1 = 35;\r\n\tpublic static final byte A_POI2 = 36;\r\n\tpublic static final byte A_POI3 = 37;\r\n\tpublic static final byte A_POI4 = 38;\r\n\tpublic static final byte A_POI5 = 39;\r\n\tpublic static final byte A_POI6 = 40;\r\n\tpublic static final byte A_POI7 = 41;\r\n\tpublic static final byte A_SATK = 42;\r\n\tpublic static final byte A_IMUATK = 43;\r\n\tpublic static final byte A_POISON = 44;\r\n\tpublic static final byte A_VOLC = 45;\r\n\tpublic static final byte A_E_VOLC = 46;\r\n\tpublic static final byte A_E_CURSE = 47;\r\n\tpublic static final byte A_WAVE = 48;\r\n\tpublic static final byte A_E_WAVE = 49;\r\n\tpublic static final byte A_ARMOR = 50;\r\n\tpublic static final byte A_E_ARMOR = 51;\r\n\tpublic static final byte A_SPEED = 52;\r\n\tpublic static final byte A_E_SPEED = 53;\r\n\tpublic static final byte A_WEAK_UP = 54;\r\n\tpublic static final byte A_E_WEAK_UP = 55;\r\n\tpublic static final byte A_HEAL = 56;\r\n\tpublic static final byte A_E_HEAL = 57;\r\n\tpublic static final byte A_DEMON_SHIELD = 58;\r\n\tpublic static final byte A_E_DEMON_SHIELD = 59;\r\n\tpublic static final byte A_COUNTER = 60;\r\n\tpublic static final byte A_E_COUNTER = 61;\r\n\tpublic static final byte A_DMGCUT = 62;\r\n\tpublic static final byte A_E_DMGCUT = 63;\r\n\tpublic static final byte A_DMGCAP = 64;\r\n\tpublic static final byte A_E_DMGCAP = 65;\r\n\tpublic static final byte[] A_POIS = { A_POI0, A_POI1, A_POI2, A_POI3, A_POI4, A_POI5, A_POI6, A_POI7 };\r\n\tpublic static final byte A_TOT = 66;\r\n\r\n\t// atk type index used in filter page\r\n\tpublic static final byte ATK_SINGLE = 0;\r\n\tpublic static final byte ATK_AREA = 1;\r\n\tpublic static final byte ATK_LD = 2;\r\n\tpublic static final byte ATK_OMNI = 4;\r\n\tpublic static final byte ATK_TOT = 8;\r\n\r\n\t// base and canon level\r\n\tpublic static final byte BASE_H = 0;\r\n\tpublic static final byte BASE_SLOW = 1;\r\n\tpublic static final byte BASE_WALL = 2;\r\n\tpublic static final byte BASE_STOP = 3;\r\n\tpublic static final byte BASE_WATER = 4;\r\n\tpublic static final byte BASE_GROUND = 5;\r\n\tpublic static final byte BASE_BARRIER = 6;\r\n\tpublic static final byte BASE_CURSE = 7;\r\n\tpublic static final byte BASE_TOT = 8;\r\n\r\n\t// base type\r\n\tpublic static final byte BASE_ATK_MAGNIFICATION = 0;\r\n\tpublic static final byte BASE_SLOW_TIME = 1;\r\n\tpublic static final byte BASE_TIME = 2;\r\n\tpublic static final byte BASE_WALL_MAGNIFICATION = 3;\r\n\tpublic static final byte BASE_WALL_ALIVE_TIME = 4;\r\n\tpublic static final byte BASE_RANGE = 5;\r\n\t//Figure out type 6\r\n\tpublic static final byte BASE_HEALTH_PERCENTAGE = 7;\r\n\t//Figure out type 8\r\n\tpublic static final byte BASE_HOLY_ATK_SURFACE = 9;\r\n\tpublic static final byte BASE_HOLY_ATK_UNDERGROUND = 10;\r\n\t//Figure out type 11\r\n\tpublic static final byte BASE_CURSE_TIME = 12;\r\n\r\n\r\n\r\n\t// touchable ID\r\n\tpublic static final byte TCH_N = 1;\r\n\tpublic static final byte TCH_KB = 2;\r\n\tpublic static final byte TCH_UG = 4;\r\n\tpublic static final byte TCH_CORPSE = 8;\r\n\tpublic static final byte TCH_SOUL = 16;\r\n\tpublic static final byte TCH_EX = 32;\r\n\tpublic static final byte TCH_ZOMBX = 64;\r\n\tpublic static final short TCH_ENTER = 128;\r\n\r\n\tpublic static final String[] A_PATH = new String[] { \"down\", \"up\", \"slow\", \"stop\", \"shield\", \"farattack\",\r\n\t\t\t\"wave_invalid\", \"wave_stop\", \"waveguard\" };\r\n\r\n\t// After this line all number is game data\r\n\r\n\tpublic static final byte INT_KB = 0, INT_HB = 1, INT_SW = 2, INT_ASS = 3, INT_WARP = 4;\r\n\r\n\tpublic static final byte[] KB_PRI = new byte[] { 2, 4, 5, 1, 3 };\r\n\tpublic static final byte[] KB_TIME = new byte[] { 11, 23, 47, 11, -1 };\r\n\tpublic static final short[] KB_DIS = new short[] { 165, 345, 705, 55, -1 };\r\n\r\n\tpublic static final byte W_E_INI = -33;\r\n\tpublic static final byte W_U_INI = -67;\r\n\tpublic static final short W_PROG = 200;\r\n\tpublic static final short W_E_WID = 500;\r\n\tpublic static final short W_U_WID = 400;\r\n\tpublic static final byte W_TIME = 3;\r\n\tpublic static final byte W_MINI_TIME = 2; // mini wave spawn interval\r\n\tpublic static final byte E_IMU = -1;\r\n\tpublic static final byte E_IWAVE = -2;\r\n\tpublic static final byte E_SWAVE = -3;\r\n\tpublic static final short W_VOLC = 375;\r\n\tpublic static final short W_VOLC_INNER = 250; // volcano inner width\r\n\tpublic static final byte W_VOLC_PIERCE = 125; // volcano pierce width\r\n\tpublic static final byte VOLC_ITV = 20;\r\n\r\n\tpublic static final byte VOLC_PRE = 15; // volcano pre-atk\r\n\tpublic static final byte VOLC_POST = 10; // volcano post-atk\r\n\tpublic static final byte VOLC_SE = 30; // volcano se loop duration\r\n\r\n\tpublic static final byte[] NYPRE = new byte[] { 18, 2, -1, 28, 37, 18, 9, 2 };// not sure, 10f for bblast\r\n\tpublic static final short[] NYRAN = new short[] { 710, 600, -1, 500, 500, 710, 100, 600 };// not sure\r\n\tpublic static final short SNIPER_CD = 300;// not sure\r\n\tpublic static final byte SNIPER_PRE = 8;// not sure\r\n\tpublic static final float SNIPER_POS = 442.5f;\r\n\tpublic static final byte REVIVE_SHOW_TIME = 16;\r\n\r\n\tpublic static final int ORB_ATK = 0;\r\n\tpublic static final int ORB_RES = 1;\r\n\tpublic static final int ORB_STRONG = 2;\r\n\tpublic static final int ORB_MASSIVE = 3;\r\n\tpublic static final int ORB_RESISTANT = 4;\r\n\tpublic static final int ORB_TYPE = 0, ORB_TRAIT = 1, ORB_GRADE = 2, ORB_TOT = 3;\r\n\r\n\tpublic static final int[] ORB_ATK_MULTI = { 100, 200, 300, 400, 500 }; // Atk orb multiplication\r\n\tpublic static final int[] ORB_RES_MULTI = { 4, 8, 12, 16, 20 }; // Resist orb multiplication\r\n\tpublic static final int[] ORB_STR_DEF_MULTI = {2, 4, 6, 8, 10};\r\n\tpublic static final double[] ORB_STR_ATK_MULTI = {0.06, 0.12, 0.18, 0.24, 0.3};\r\n\tpublic static final double[] ORB_MASSIVE_MULTI = {0.1, 0.2, 0.3, 0.4, 0.5};\r\n\tpublic static final int[] ORB_RESISTANT_MULTI = {5, 10, 15, 20, 25};\r\n\r\n\tpublic static final int MUSIC_DELAY = 2344; //Music change delay with milliseconds accuracy\r\n\r\n\tpublic static final int LINEUP_CHANGE_TIME = 6; //in frame\r\n\r\n\tpublic static final int BG_EFFECT_STAR = 0;\r\n\tpublic static final int BG_EFFECT_RAIN = 1;\r\n\tpublic static final int BG_EFFECT_BUBBLE = 2;\r\n\tpublic static final int BG_EFFECT_FALLING_SNOW = 3;\r\n\tpublic static final int BG_EFFECT_SNOW = 4;\r\n\tpublic static final int BG_EFFECT_SNOWSTAR = 5;\r\n\tpublic static final int BG_EFFECT_BLIZZARD = 6;\r\n\tpublic static final int BG_EFFECT_SHINING = 7;\r\n\tpublic static final int BG_EFFECT_BALLOON = 8;\r\n\tpublic static final int BG_EFFECT_ROCK = 9;\r\n\r\n\t//Below are completely guessed\r\n\tpublic static final int BG_EFFECT_STAR_TIME = 35;\r\n\tpublic static final int BG_EFFECT_STAR_Y_RANGE = 140;\r\n\tpublic static final int BG_EFFECT_SPLASH_MIN_HEIGHT = 90;\r\n\tpublic static final int BG_EFFECT_SPLASH_RANGE = 60;\r\n\tpublic static final int BG_EFFECT_BUBBLE_TIME = 780;\r\n\tpublic static final int BG_EFFECT_BUBBLE_FACTOR = 32;\r\n\tpublic static final int BG_EFFECT_BUBBLE_STABILIZER = 7;\r\n\tpublic static final int BG_EFFECT_SNOW_SPEED = 8;\r\n\tpublic static final double[] BG_EFFECT_BLIZZARD_SIZE = {1.0, 1.5, 2.0};\r\n\tpublic static final int BG_EFFECT_BLIZZARD_SPEED = 40;\r\n\tpublic static final int BG_EFFECT_FALLING_SNOW_SPEED = 3;\r\n\tpublic static final double BG_EFFECT_FALLING_SNOW_SIZE = 2.0;\r\n\tpublic static final int BG_EFFECT_SHINING_TIME = 8;\r\n\tpublic static final int BG_EFFECT_BALLOON_SPEED = 1;\r\n\tpublic static final int BG_EFFECT_BALLOON_FACTOR = 32;\r\n\tpublic static final int BG_EFFECT_BALLOON_STABILIZER = 25;\r\n\tpublic static final double[] BG_EFFECT_ROCK_SIZE = {1.0, 2.25};\r\n\tpublic static final int[] BG_EFFECT_ROCK_SPEED = {1, 3};\r\n\tpublic static final int BG_EFFECT_ROCK_BEHIND_SPAWN_OFFSET = 190;\r\n\r\n\tpublic static final String[] SUFX = new String[] { \"f\", \"c\", \"s\" };\r\n\r\n\tpublic static EffAnimStore effas() {\r\n\t\treturn CommonStatic.getBCAssets().effas;\r\n\t}\r\n\r\n\t/**\r\n\t * convenient method to log an unexpected error. Don't use it to process any\r\n\t * expected error\r\n\t */\r\n\tpublic static boolean err(RunExc s) {\r\n\t\treturn CommonStatic.ctx.noticeErr(s, ErrType.ERROR, \"unexpected error\");\r\n\t}\r\n\r\n\t/**\r\n\t * convenient method to log an unexpected error. Don't use it to process any\r\n\t * expected error\r\n\t */\r\n\tpublic static <T> T err(SupExc<T> s) {\r\n\t\treturn CommonStatic.ctx.noticeErr(s, ErrType.ERROR, \"unexpected error\");\r\n\t}\r\n\r\n\tpublic static int getVer(String ver) {\r\n\t\tint ans = 0;\r\n\t\tint[] strs = CommonStatic.parseIntsN(ver);\r\n\t\tfor (int str : strs) {\r\n\t\t\tans *= 100;\r\n\t\t\tans += str;\r\n\t\t}\r\n\t\treturn ans;\r\n\t}\r\n\r\n\tpublic static String hex(int id) {\r\n\t\treturn trio(id / 1000) + trio(id % 1000);\r\n\t}\r\n\r\n\tpublic static <T> T ignore(SupExc<T> sup) {\r\n\t\ttry {\r\n\t\t\treturn sup.get();\r\n\t\t} catch (Exception e) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static String restrict(String str) {\r\n\t\tif (str.length() < restrict_name)\r\n\t\t\treturn str;\r\n\t\treturn str.substring(0, restrict_name);\r\n\t}\r\n\r\n\tpublic static String revVer(int ver) {\r\n\t\treturn ver / 1000000 % 100 + \"-\" + ver / 10000 % 100 + \"-\" + ver / 100 % 100 + \"-\" + ver % 100;\r\n\t}\r\n\r\n\tpublic static String duo(int i) {\r\n\t\tif(i < 10) {\r\n\t\t\treturn \"0\"+ i;\r\n\t\t} else {\r\n\t\t\treturn \"\" + i;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static String trio(int i) {\r\n\t\tif(i < 10)\r\n\t\t\treturn \"00\" + i;\r\n\t\telse if(i < 100)\r\n\t\t\treturn \"0\" + i;\r\n\t\telse\r\n\t\t\treturn \"\" + i;\r\n\t}\r\n\r\n\tpublic static int reorderTrait(int oldTrait) {\r\n\t\tint newTrait = 0;\r\n\r\n\t\tfor(int i = 0; i < TRAIT_TOT; i++) {\r\n\t\t\tif(((oldTrait >> i) & 1) > 0) {\r\n\t\t\t\tswitch (i) {\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\tnewTrait |= TB_WHITE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tnewTrait |= TB_RED;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tnewTrait |= TB_FLOAT;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tnewTrait |= TB_BLACK;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\tnewTrait |= TB_METAL;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\tnewTrait |= TB_ANGEL;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\tnewTrait |= TB_ALIEN;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 7:\r\n\t\t\t\t\t\tnewTrait |= TB_ZOMBIE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 8:\r\n\t\t\t\t\t\tnewTrait |= TB_RELIC;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tnewTrait |= 1 << i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newTrait;\r\n\t}\r\n\r\n\tpublic static int reorderAbi(int ab, int ver) {\r\n\t\tint newAbi = 0, abiAdd = 0;\r\n\t\tif (ver == 0) {\r\n\t\t\tfor (int i = 0; i + abiAdd < ABI_TOT + 2; i++) {\r\n\t\t\t\tif (i == 7 || i == 12 || i == 18)\r\n\t\t\t\t\tabiAdd++;\r\n\t\t\t\tint i1 = i + abiAdd;\r\n\t\t\t\tif (i1 == 12 || i1 == 18)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tif (((ab >> i1) & 1) > 0)\r\n\t\t\t\t\tnewAbi |= 1 << i;\r\n\t\t\t}\r\n\t\t} else if (ver == 1) { //Reformat Bounty and Base destroyer\r\n\t\t\tfor (int i = 0; i + abiAdd < ABI_TOT; i++) {\r\n\t\t\t\tif (i == 4)\r\n\t\t\t\t\tabiAdd += 2;\r\n\t\t\t\tint i1 = i + abiAdd;\r\n\t\t\t\tif (((ab >> i1) & 1) > 0)\r\n\t\t\t\t\tnewAbi |= 1 << i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn newAbi;\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/common/util/Data.java b/app/src/main/java/common/util/Data.java
--- a/app/src/main/java/common/util/Data.java	(revision dd4cf2c03a162e1c6ad15cdb6131e564e71f2ebc)
+++ b/app/src/main/java/common/util/Data.java	(date 1653236148920)
@@ -900,7 +900,7 @@
 	public static final byte RARITY_TOT = 6;
 
 	// trait bit filter
-	public static final byte TB_RED = 1;
+	public static final int TB_RED = 1;
 	public static final byte TB_FLOAT = 2;
 	public static final byte TB_BLACK = 4;
 	public static final byte TB_METAL = 8;
@@ -953,7 +953,7 @@
 	public static final byte LV_RECH = 5;
 	public static final byte LV_CATK = 6;
 	public static final byte LV_CRG = 7;
-	public static final byte LV_XP = 8;
+	public static final int LV_XP = 8;
 	public static final byte LV_TOT = 9;
 
 	// default treasure value
@@ -969,8 +969,8 @@
 	public static final byte T_RECH = 6;
 	public static final byte T_CATK = 7;
 	public static final byte T_BASE = 8;
-	public static final byte T_XP1 = 9;
-	public static final byte T_XP2 = 10;
+	public static final int T_XP1 = 9;
+	public static final int T_XP2 = 10;
 	public static final byte T_TOT = 11;
 
 	// abi bit filter
@@ -1391,7 +1391,7 @@
 	public static final byte BASE_GROUND = 5;
 	public static final byte BASE_BARRIER = 6;
 	public static final byte BASE_CURSE = 7;
-	public static final byte BASE_TOT = 8;
+	public static final int BASE_TOT = 8;
 
 	// base type
 	public static final byte BASE_ATK_MAGNIFICATION = 0;
Index: app/src/main/java/common/battle/entity/EEnemy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package common.battle.entity;\r\n\r\nimport common.battle.StageBasis;\r\nimport common.battle.attack.AtkModelUnit;\r\nimport common.battle.attack.AttackAb;\r\nimport common.battle.attack.AttackWave;\r\nimport common.battle.data.MaskEnemy;\r\nimport common.battle.data.MaskUnit;\r\nimport common.pack.UserProfile;\r\nimport common.util.Data;\r\nimport common.util.anim.EAnimU;\r\nimport common.util.unit.Trait;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class EEnemy extends Entity {\r\n\r\n\tpublic final byte mark;\r\n\tpublic final double mult, mula;\r\n\r\n\tpublic byte hit;\r\n\r\n\tpublic EEnemy(StageBasis b, MaskEnemy de, EAnimU ea, double magnif, double atkMagnif, int d0, int d1, int m) {\r\n\t\tsuper(b, de, ea, atkMagnif, magnif);\r\n\t\tmult = magnif;\r\n\t\tmula = atkMagnif;\r\n\t\tmark = (byte) m;\r\n\t\tisBase = mark <= -1;\r\n\t\tlayer = d0 + (int) (b.r.nextDouble() * (d1 - d0 + 1));\r\n\t\ttraits = de.getTraits();\r\n\r\n\t\tcanBurrow = mark != 1;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic int getAtk() {\r\n\t\tint atk = aam.getAtk();\r\n\t\tif (status[P_WEAK][0] > 0)\r\n\t\t\tatk = atk * status[P_WEAK][1] / 100;\r\n\t\tif (status[P_STRONG][0] != 0)\r\n\t\t\tatk += atk * status[P_STRONG][0] / 100;\r\n\t\treturn atk;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void kill(boolean atk) {\r\n\t\tsuper.kill(atk);\r\n\t\tif (!basis.st.trail && !atk) {\r\n\t\t\tdouble mul = basis.b.t().getDropMulti() * (1 + (status[P_BOUNTY][0] / 100.0));\r\n\t\t\tbasis.money += mul * ((MaskEnemy) data).getDrop();\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tprotected int getDamage(AttackAb atk, int ans) {\r\n\t\tif (atk instanceof AttackWave && atk.waveType == WT_MINI) {\r\n\t\t\tans = (int) ((double) ans * atk.getProc().MINIWAVE.multi / 100.0);\r\n\t\t}\r\n\t\tif (atk.model instanceof AtkModelUnit && status[P_CURSE][0] == 0) {\r\n\t\t\tArrayList<Trait> sharedTraits = new ArrayList<>(atk.trait);\r\n\t\t\tsharedTraits.retainAll(traits);\r\n\t\t\tboolean isAntiTraited = targetTraited(atk.trait);\r\n\t\t\tfor (Trait t : atk.trait) {\r\n\t\t\t\tif (t.BCTrait || sharedTraits.contains(t))\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tif ((t.targetType && isAntiTraited) || t.others.contains(((MaskUnit)atk.attacker.data).getPack()))\r\n\t\t\t\t\tsharedTraits.add(t);\r\n\t\t\t}\r\n\t\t\tif ((atk.abi & AB_GOOD) != 0)\r\n\t\t\t\tans *= EUnit.OrbHandler.getOrbGood(atk, sharedTraits, basis.b.t());\r\n\t\t\tif ((atk.abi & AB_MASSIVE) != 0)\r\n\t\t\t\tans *= EUnit.OrbHandler.getOrbMassive(atk, sharedTraits, basis.b.t());\r\n\t\t\tif (!sharedTraits.isEmpty() && (atk.abi & AB_MASSIVES) != 0)\r\n\t\t\t\tans *= basis.b.t().getMASSIVESATK(sharedTraits);\r\n\t\t}\r\n\t\tif (isBase)\r\n\t\t\tans *= 1 + atk.getProc().ATKBASE.mult / 100.0;\r\n\t\tif (traits.contains(UserProfile.getBCData().traits.get(TRAIT_WITCH)) && (atk.abi & AB_WKILL) > 0)\r\n\t\t\tans *= basis.b.t().getWKAtk();\r\n\t\tif (traits.contains(UserProfile.getBCData().traits.get(TRAIT_EVA)) && (atk.abi & AB_EKILL) > 0)\r\n\t\t\tans *= basis.b.t().getEKAtk();\r\n\t\tif (traits.contains(UserProfile.getBCData().traits.get(TRAIT_BARON)) && (atk.abi & AB_BAKILL) > 0)\r\n\t\t\tans *= 1.6;\r\n\t\tif (traits.contains(UserProfile.getBCData().traits.get(Data.TRAIT_BEAST)) && atk.getProc().BSTHUNT.type.active)\r\n\t\t\tans *= 2.5;\r\n\t\tif (atk.canon == 16)\r\n\t\t\tif ((touchable() & TCH_UG) > 0)\r\n\t\t\t\tans = (int) (maxH * basis.b.t().getCannonMagnification(5, BASE_HOLY_ATK_UNDERGROUND));\r\n\t\t\telse\r\n\t\t\t\tans = (int) (maxH * basis.b.t().getCannonMagnification(5, BASE_HOLY_ATK_SURFACE));\r\n\t\tans = critCalc(data.getTraits().contains(UserProfile.getBCData().traits.get(TRAIT_METAL)), ans, atk);\r\n\r\n\t\t// Perform Orb\r\n\t\tans += EUnit.OrbHandler.getOrbAtk(atk, this);\r\n\r\n\t\treturn ans;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected double getLim() {\r\n\t\tdouble ans;\r\n\t\tdouble minPos = ((MaskEnemy) data).getLimit();\r\n\r\n\t\tif (mark == 1)\r\n\t\t\tans = pos - (minPos + basis.boss_spawn); // guessed value compared to BC\r\n\t\telse\r\n\t\t\tans = pos - minPos;\r\n\t\treturn Math.max(0, ans);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected int traitType() {\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void damaged(AttackAb atk) {\r\n\t\thit = 2;\r\n\t\tsuper.damaged(atk);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void update() {\r\n\t\tif(hit > 0) {\r\n\t\t\thit--;\r\n\t\t}\r\n\r\n\t\tsuper.update();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void postUpdate() {\r\n\t\tsuper.postUpdate();\r\n\r\n\t\tif (health > 0)\r\n\t\t\tstatus[P_BOUNTY][0] = 0;\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/common/battle/entity/EEnemy.java b/app/src/main/java/common/battle/entity/EEnemy.java
--- a/app/src/main/java/common/battle/entity/EEnemy.java	(revision dd4cf2c03a162e1c6ad15cdb6131e564e71f2ebc)
+++ b/app/src/main/java/common/battle/entity/EEnemy.java	(date 1653236578440)
@@ -15,7 +15,7 @@
 
 public class EEnemy extends Entity {
 
-	public final byte mark;
+	public final int mark;
 	public final double mult, mula;
 
 	public byte hit;
@@ -24,7 +24,7 @@
 		super(b, de, ea, atkMagnif, magnif);
 		mult = magnif;
 		mula = atkMagnif;
-		mark = (byte) m;
+		mark = m;
 		isBase = mark <= -1;
 		layer = d0 + (int) (b.r.nextDouble() * (d1 - d0 + 1));
 		traits = de.getTraits();
